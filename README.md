# Общее описание задания

Создайте калькулятор, который генерирует полный конфигурационный файл на основе входных параметров, описывающих ожидаемую производительность системы.

## Пример:
Предположим, у нас есть система, состоящая из двух сервисов: `service_1` и `service_2`. Конфигурация этих сервисов зависит от двух входных параметров, которые может настроить клиент: `disk_storage_MB` и `traffic_mb`.

Конфигурация сервисов зависит от параметров следующим образом:

### Таблица конфигурации:
| Сервис      | Конфигурация       | enabled (bool)                 | nodes (int)                      | cpu_cores (int)              | memory (float)               |
|-------------|--------------------|--------------------------------|----------------------------------|-------------------------------|------------------------------|
| `service_1` |                    | `True`, если `traffic_mb > 0`, иначе `False` | `[disk_storage_MB / 10000]`       | 5                             | `[disk_storage_MB / 10000]`   |
| `service_2` |                    | `True`, если `traffic_mb > 0`, иначе `False` | 2, если `[disk_storage_MB / 10000] > 3`, иначе 1 | `[traffic_mb / 1000]`         | 100                          |

На вход калькулятор получает текущую конфигурацию сервисов в виде файла JSON или словаря. Он также может получить неполную конфигурацию или просто пустой файл JSON. После получения текущей конфигурации и входных параметров `disk_storage_MB` и `traffic_mb`, калькулятор должен корректно изменить конфигурацию сервисов в соответствии с заданными входными параметрами и таблицей зависимостей конфигурации.

### Python-код:
```python
import copy
import math

class Calculator:
    def __init__(self, config: dict):
        self._config = config

    def update_config(self, disk_storage: int, traffic: int) -> dict:
        buffer = copy.deepcopy(self._config)
        buffer['service_1']['enabled'] = True if traffic > 0 else False
        buffer['service_1']['nodes'] = math.ceil(disk_storage / 10000)
        buffer['service_1']['cpu_cores'] = 5
        buffer['service_1']['memory'] = math.ceil(disk_storage / 10000)

        buffer['service_2']['enabled'] = True if traffic > 0 else False
        buffer['service_2']['nodes'] = 2 if math.ceil(disk_storage / 10000) > 3 else 1
        buffer['service_2']['cpu_cores'] = math.ceil(traffic / 1000)
        buffer['service_2']['memory'] = 100

        return buffer

if __name__ == '__main__':
    config = {
        'service_1': {
            'enabled': False,
            'nodes': 0,
            'cpu_cores': 0,
            'memory': 0
        },
        'service_2': {
            'enabled': True,
            'nodes': 1,
            'cpu_cores': 10,
            'memory': 100
        }
    }

    calculator = Calculator(config)
    updated_config = calculator.update_config(100, 100)
```

# Процесс получения и передачи результата

Дополнительные условия: Формат получения и передачи результата может быть любым, необходимо только предоставить инструкцию по использованию. Это может быть класс или отдельный файл. Код может быть запущен как консольный скрипт или напрямую импортирован из пакета. Выберите наиболее удобный для этого сервиса формат поставки, если бы такой сервис использовался внутри одного из продуктов Лаборатории, и опишите почему был выбран именно такой вариант.

В задании не ограничивается число или порядок шагов, которые может содержать алгоритм. Интерфейс для использования калькулятора тоже нужно выбрать самостоятельно.

Для решения задачи можно использовать только стандартную библиотеку и любую актуальную версию Python. Решение не должно требовать установки никаких дополнительных зависимостей. Решение должно быть расширяемым, так как в процессе жизненного цикла могут появляться новые сервисы или изменяться (усложняться) зависимости вычисления конфигурации для уже существующих сервисов.

Алгоритм вычисления параметров для сервисов должен быть максимально читабельным и изолирован от обслуживающего кода, в данном случае от загрузки значений из базы логов. Конфигурация сервисов должна быть валидным JSON, соответственно возможно наличие дополнительных параметров сервиса, на которые не завязаны вычисления параметров.

При изменении формата конфигурации сервиса, при условии что значения калькулятора параметров не меняются (не меняется их расположение в конфигурации сервиса и тип), калькулятор должен продолжать работать корректно. Таблица зависимости конфигурации сервисов от входных параметров является точной документацией, логика, описанная внутри неё, может быть реализована в любом виде, как с помощью скрипта внутри файла или просто в теле функции.

Считается допустимым, что в процессе выполнения задания таблица может изменять исходный вид. Выберите наиболее удобный для вашего решения вариант записи зависимости логики (исходный код, текстовый файл, математические формулы, специальный язык и т.д.), однако учитывайте, что правила в таблице могут усложняться или просто быть описаны текстом (формат заполнения ячеек свободный).

## Таблица параметров

Ниже будет описана таблица зависимости конфигурации сервисов от входных параметров. В рамках тестового задания необходимо полностью реализовать указанную в ней логику, соблюдая условия из разделов выше. Зависимости параметров сервисов от входных параметров в таблице записаны с использованием формул из пакета офисного ПО LibreOffice (LibreOffice Calc), необходимо точно передать логику работы формул, синтаксис сохранять не требуется.

### Входные параметры

| Параметр        | Тип      |
|-----------------|----------|
| agents          | int      |
| storage         | float    |
| traffic         | float    |
| mail_traffic    | float    |
| distributed     | bool     |
| nodes           | int      |

### Таблица зависимостей

| Сервис               | Параметр   | Формула                                                                                     |
|----------------------|------------|---------------------------------------------------------------------------------------------|
| **kafka**            | replicas   | `=ЕСЛИ(distributed=1;3;1)`                                                                  |
|                      | memory     | `=ЕСЛИ(distributed.mail_traffic*0,5;100)`                                                   |
|                      | cpu        | `=ОКРУГЛВВЕРХ(0,000169agents^0,437923nodes^3;2)`                                             |
|                      | storage    | `=ОКРУГЛВВЕРХ(0,0004*agents^0,3231;3)`                                                      |
| **elasticsearch**    | replicas   | `=ЕСЛИ(distributed=1;3;1)`                                                                  |
|                      | memory     | 0                                                                                           |
|                      | cpu        | 3                                                                                           |
|                      | storage    | `=ЕСЛИ(agents<=5000;0,256;ЕСЛИ(agents<=10000;0,512;1))`                                      |
| **processor**        | replicas   | `=ЕСЛИ(agents>0;ЕСЛИ(distributed=1;3;0);0)`                                                 |
|                      | memory     | `=ЕСЛИ(distributed=1;5;100)`                                                                |
|                      | cpu        | 3                                                                                           |
|                      | storage    | `=ЕСЛИ(nodes>0;ОКРУГЛВВЕРХ(4,25870,98271^nagents);3);0)`                                    |
| **server**           | replicas   | `=ЕСЛИ(agents>0;ЕСЛИ(distributed=1;МНН(PS3;2);0);МНН(PS3;2);0)`                            |
|                      | memory     | `=ЕСЛИ(distributed=1;ОКРУГЛ(1/storage*1,6;3);100)`                                          |
|                      | cpu        | 1                                                                                           |
|                      | storage    | `=ЕСЛИ(nodes>0;ОКРУГЛВВЕРХ(0,0109*agents^2+3154);3);0)`                                      |
| **database_server**  | replicas   | `=ЕСЛИ(agents>0;ЕСЛИ(distributed=1;МАКС(ОКРУГЛ(1/agents*15000);1);1);0)`                   |
|                      | memory     | `=ЕСЛИ(distributed=1;ОКРУГЛ(1/storage*1,6;3);100)`                                          |
|                      | cpu        | 1                                                                                           |
|                      | storage    | `=ЕСЛИ(nodes>0;ОКРУГЛВВЕРХ(0,0000002agents^3+0,0006774agents^4,5*agents/nodes;3);0)`        |
| **clickhouse**       | replicas   | `=ЕСЛИ(agents>0;ЕСЛИ(distributed=1;МАКС(ОКРУГЛ(1/agents*15000);1);1);0)`                   |
|                      | memory     | `=ЕСЛИ(distributed=1;ОКРУГЛ(1/storage*1,6;3);100)`                                          |
|                      | cpu        | 1                                                                                           |
|                      | storage    | `=ЕСЛИ(distributed=0;ОКРУГЛВВЕРХ(0,0000628*agents^0,6377;3);0)`                             |
| **synchronizer**     | replicas   | `=ЕСЛИ(agents=0;1;0)`                                                                        |
|                      | memory     | `=ЕСЛИ(distributed;ОКРУГЛВВЕРХ(storage/5000,3)*1,6;100)`                                    |
|                      | cpu        | 1                                                                                           |
|                      | storage    | `=ЕСЛИ(distributed=0;ОКРУГЛВВЕРХ(0,0002*agents^0,6;3);0)`                                   |
| **scanner**          | replicas   | `=ЕСЛИ(agents=0;1;0)`                                                                        |
|                      | memory     | 300                                                                                         |
|                      | cpu        | 3                                                                                           |
|                      | storage    | `=ЕСЛИ(distributed=0;ОКРУГЛВВЕРХ(0,0002*agents^0,6;3);0)`                                   |


## Юнит-тесты

В рамках задания так-же необходимо реализовать набор юнит-тестов для написанного кода. Важно, что-бы сценарии проверяемые юнит
тестами не были избыточными, но при этом эффективно отлавливали ошибки. Код юнит-тестов будет оцениваться наравне с кодом самого 
сервиса.  Тесты должны быть устойчивы к изменению исходного кода, они не должны быть "хрупкими". Для написания юнит-тестов следует 
использовать 
pytest, это единственный случай, где допускается использование пакета не из стандартной библиотеки
